import os
from tempfile import NamedTemporaryFile
import json
import subprocess

from jinja2 import Environment, PackageLoader, select_autoescape
import arc

from status import JOB_STATUSES
from config import ConnectionConfig
from exceptions import (InvalidConfigError, ProxyGenerationError, InvalidJobDescription,
                        JobSubmissionError, NoTargetsAvailableError)


# Location of directory containing templates for JSDL XML
TEMPLATES_DIR = "templates"


class ArcInterface(object):
    """
    Class to handle interactions with the ARC-CE server
    """

    def __init__(self, config_path=None):
        """
        Create an object to interface with the ARC server.

        :param config_path: Path to config JSON file, or ``None`` to use the default settings
        :raises InvalidConfigError: if config is not valid JSON or is otherwise invalid
        """
        try:
            config_dict = None

            if config_path:
                # Let errors reading file bubble to calling code
                with open(config_path) as config_file:
                    config_dict = json.load(config_file)

            self.config = ConnectionConfig.create_config(config_dict)
            ConnectionConfig.validate(self.config)

        # Catch JSON parsing errors
        except ValueError as e:
            raise InvalidConfigError(e.message)

        # Create jinja2 environment for loading JSDL template(s)
        self.env = Environment(loader=PackageLoader(__name__, TEMPLATES_DIR),
                               autoescape=select_autoescape(["xml"]))

    def submit_job(self, executable, *args):
        """
        Submit a job and return the job ID

        :param executable: The command to run on the LOTUS cluster
        :param *args: Arguments to pass to the executable

        :raises ProxyGenerationError: if a proxy certificate cannot be generated by ``arcproxy``
        :raises NoTargetsAvailableError: if no execution targets can be found on the ARC server
        :raises JobSubmissionError: if the job cannot be submitted to any targets

        :return: Job ID
        """
        endpoint = arc.Endpoint(self.config["arc_server"], arc.Endpoint.COMPUTINGINFO)

        # Create proxy from private key and certificate
        try:
            subprocess.check_call([self.config["arcproxy_path"],
                                   "-C", self.config["client_cert_file"],
                                   "-K", self.config["pem_file"],
                                   "-P", self.config["proxy_file"]])
        except subprocess.CalledProcessError:
            raise ProxyGenerationError("Could not create proxy with arcproxy")

        except OSError as ex:
            raise OSError("Failed to run arcproxy command: {}".format(ex))

        user_config = arc.UserConfig()
        user_config.ProxyPath(self.config["proxy_file"])
        user_config.CACertificatesDirectory(self.config["certs_dir"])

        # Get the ExecutionTargets of this ComputingElement
        retriever = arc.ComputingServiceRetriever(user_config, [endpoint])
        retriever.wait()
        targets = retriever.GetExecutionTargets()

        if len(targets) == 0:
            raise NoTargetsAvailableError("No targets available")

        template = self.env.get_template("job_template.xml")
        jsdl = template.render({
            "name": "ARC job",  # TODO: Use sensible name or omit
            "executable": executable,
            "arguments": args
        })
        job_descriptions = self.get_job_descriptions(jsdl)

        # Create an empty job object which will contain our submitted job
        job = arc.Job()

        # Submit job directly to the execution targets, without a broker
        # Try each target until successfully submitted
        for target in targets:
            if target.Submit(user_config, job_descriptions[0], job):
                break
        else:
            raise JobSubmissionError("Could not submit job to any of the {} available target(s)"
                                     .format(len(targets)))

        print("Started job {}".format(job.JobID))
        return job.JobID

    def get_job_status(self, job_id):
        """
        Return the status of the given job
        """
        return JOB_STATUSES.COMPLETED

    def cancel_job(self, job_id):
        """
        Cancel the given job
        """
        print("Cancelling job {}".format(job_id))

    def save_job_outputs(self, job_id, output_path=None, errors_path=None):
        """
        Retrieve the output and errors files for a job and save them to the paths given
        """
        if output_path:
            print("Saving output file to '{}'".format(output_path))

        if errors_path:
            print("Saving errors file to '{}'".format(errors_path))

    def get_job_descriptions(self, jsdl):
        """
        Return an instance of ``arc.JobDescriptionList`` containing the job described by the given JSDL

        :param jsdl: String containing the job description in JSDL format
        """
        job_descriptions = arc.JobDescriptionList()
        temp_filename = None
        with NamedTemporaryFile(delete=False) as temp_file:
            temp_filename = temp_file.name
            temp_file.write(jsdl)

        try:
            if not arc.JobDescription_ParseFromFile(temp_filename, job_descriptions):
                raise InvalidJobDescription("Could not parse job description XML")
        finally:
            # Delete the temp file - finally clause is run even if exception is raised
            os.unlink(temp_filename)

        return job_descriptions

